/**
 * Falsy Values: false, 0, "", null, undefined, NaN
 */

/**
 * Augments the Function type object's prototype with a method called "method."
 * This method allows any Constructor Function, that prototypally inherits from
 * Function.prototype (so all Constructor Functions), to easily add methods to
 * their own prototype objects.
 *
 * @param name is the name of the method passed as a String object argument.
 * @param func is the first-class function object passed in as an argument.
 * @return {*} a reference to your respective Constructor Function.
 */
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};

/**
 * Module Dependencies.
 */
var message = require('./message.js');

/**
 * Represents a collection of Message instances.
 *
 * @see Message
 * @return {*}
 * @constructor
 */
function Messages() {
    this._messages = [];
    return this;
}

/**
 * Allows for the addition of a Message instance to the Messages collection.
 *
 * @param actions should be an instance of Message.
 * @return {*} for chaining.
 */
Messages.method('addMessage', function (actions) {
    var messages = this._messages;
    if (message.isPrototypeOf(actions) && messages.lastIndexOf(actions) === -1) {
        messages.push(actions);
    }
    return this;
});

/**
 * Allows for the introspection of a collection of Messages to check if one of the contained Messages is meant for a
 * particular request/response exchange within a client-server transfer protocol.
 *
 * Example: Messages.hasMessageForExchange('entry', '200')
 * This is the same as asking "is there a Message within this collection that's meant to represent a hypermedia payload
 * for a HTTP 200 response to a request to the entry point of the API?"
 *
 * @param request should be a string representative of an Affordance identifier within an instance of Hapi.
 * @param response should be a string representative of a client-server transfer protocol response code.
 * @return true, if a Message was found for the request/response exchange; false, otherwise.
 */
Messages.method('hasMessageForExchange', function (request, response) {
    var messages = this._messages;
    if (typeof request === 'string' &&
        typeof response === 'string') {
        for (var message in messages) {
            message = messages[message];
            if (message.isForExchange(request, response)) {
                return true;
            }
        }
    }
    return false;
});

/**
 * Allows for the retrieval of a Message from a collection of Messages if it is meant for a particular request/response
 * exchange within a client-server transfer protocol.
 *
 * Example: Messages.getMessageForExchange('entry', '200')
 * This is the same as saying "give me a Message within this collection that's meant to represent a hypermedia payload
 * for a HTTP 200 response to a request to the entry point of the API."
 *
 * @param request should be a string representative of an Affordance identifier within an instance of Hapi.
 * @param response should be a string representative of a client-server transfer protocol response code.
 * @return {Message}, if one was found for the request/response exchange; null, otherwise.
 */
Messages.method('getMessageForExchange', function (request, response) {
    var messages = this._messages;
    if (typeof request === 'string' &&
        typeof response === 'string') {
        for (var message in messages) {
            message = messages[message];
            if (message.isForExchange(request, response)) {
                /**
                 * Consider eventually creating a shallow copy of the Message before returning it.
                 */
                return message;
            }
        }
    }
    return null;
});

/**
 * Accessor method to get the amount of Message children within an instance of Messages.
 *
 * @return Number indicative of the amount of Message children within this instance.
 */
Messages.method('getCount', function () {
    return this._messages.length;
});

/**
 * Convenience method to enforce safe method invocations without the use of the new operator.
 *
 * @return {Messages}
 */
function messages() {
    return new Messages();
}

/**
 * Convenience method to allow for type checking outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to test the prototypal inheritance chain on.
 * @return {Boolean}
 */
messages.isPrototypeOf = function (object) {
    return object instanceof Messages;
};

/**
 * Convenience method to allow for duck-type checking of a generic Object outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to duck-type check as a Messages.
 * @return {Boolean}
 */
messages.canRevive = function (object) {
    return !!object &&
        typeof object === 'object' &&
        Array.isArray(object._messages);
};

/**
 * Convenience method to allow for reviving a JSON encoded Messages outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to revive to an Messages instance.
 * @return {Messages} if revivable; null, otherwise.
 */
messages.revive = function (object) {
    if (!!object &&
        typeof object === 'object' &&
        Array.isArray(object._messages)) {
        var instance = new Messages(),
            messages = object._messages;

        for (var message in messages) {
            message = messages[message];
            instance.addMessage(message);
        }
        return instance;
    }
    return null;
};

module.exports = exports = messages;
