/**
 * Falsy Values: false, 0, "", null, undefined, NaN
 */

/**
 * Augments the Function type object's prototype with a method called "method."
 * This method allows any Constructor Function, that prototypally inherits from
 * Function.prototype (so all Constructor Functions), to easily add methods to
 * their own prototype objects.
 *
 * @param name is the name of the method passed as a String object argument.
 * @param func is the first-class function object passed in as an argument.
 * @return {*} a reference to your respective Constructor Function.
 */
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};

/**
 * Psychologist James J. Gibson originally introduced the term in his 1977 article "The Theory of Affordances"[1] and
 * explored it more fully in his book The Ecological Approach to Visual Perception[2] in 1979. He defined affordances
 * as all "action possibilities" latent in the environment, objectively measurable and independent of the individual's
 * ability to recognize them, but always in relation to agents and therefore dependent on their capabilities.
 * For instance, a set of steps which rises four feet high does not afford the act of climbing if the actor is a
 * crawling infant. Gibson's is the prevalent definition in cognitive psychology.
 *
 * Fielding mentioned hypermedia as the way to modify state on a distributed network. In this he meant “the simultaneous
 * presentation of information and controls such that the information becomes the affordance through which the user
 * obtains choices and selects actions.”
 *
 * “REST is defined by four interface constraints: identification of resources; manipulation of resources through
 * representations; self-descriptive messages; and, hypermedia as the engine of application state.” In the context of
 * this application, a Message is a collection of "action possibilities" from a Resource-Oriented
 * Architecture web API that facilitates the fourth interface constraint of REST.
 *
 * The "action possibilities" are Affordance identifier Strings.
 *
 * @param request should be a String identifier from an Affordance. These are arbitrary, but globally unique Strings
 * from the Affordances collection representing an API.
 * Example: 'entry', or 'get-users'
 * @param response should be a String representative of a response code from a client-server protocol capable of
 * facilitating REST.
 * Example: '200', or '400' given HTTP as the transfer protocol.
 * @param message should be an Array of String identifiers representing the Affordances allowed within the message of
 * the request-response transaction.
 * Example: ['entry'], or ['entry', 'get-users']
 * @return {*}
 * @constructor
 */
function Message(request, response, message) {
    this._request = (typeof request === 'string') ? request : '';
    this._response = (typeof response === 'string') ? response : '';
    this._message = Array.isArray(message) ? message : [];
    return this;
}

/**
 * Accessor method to allow the setting of the request field.
 *
 * @param request should be a String identifier from an Affordance. These are arbitrary, but globally unique Strings
 * from the Affordances collection representing an API.
 * Example: 'entry', or 'get-users'
 * @return {*} for chaining.
 */
Message.method('setRequest', function (request) {
    this._request = (typeof request === 'string') ? request : this._request;
    return this;
});

/**
 * Accessor method to allow the setting of the response field.
 *
 * @param response should be a String representative of a response code from a client-server protocol capable of
 * facilitating REST.
 * Example: '200', or '400' given HTTP as the transfer protocol.
 * @return {*} for chaining.
 */
Message.method('setResponse', function (response) {
    this._response = (typeof response === 'string') ? response : this._response;
    return this;
});

/**
 * Accessor method to allow the setting of the message field.
 *
 * @param message should be an Array of String identifiers representing the Affordances allowed within the message of
 * the request-response transaction.
 * Example: ['entry'], or ['entry', 'get-users']
 * @return {*} for chaining.
 */
Message.method('setMessage', function (message) {
    this._message = Array.isArray(message) ? message : this._message;
    return this;
});

/**
 * Allows for the addition of a String identifier of an Affordance to the Affordance-Rich Message.
 *
 * @param id should be a String identifier from an Affordance. These are arbitrary, but globally unique Strings
 * from the Affordances collection representing an API.
 * Example: 'entry', or 'get-users'
 * @return {*} for chaining.
 */
Message.method('addAffordance', function (id) {
    var message = this._message;
    if (typeof id === 'string' && message.lastIndexOf(id) === -1) {
        message.push(id);
    }
    return this;
});

/**
 * Convenience method to enforce safe method invocations without the use of the new operator.
 *
 * @param request should be a String identifier from an Affordance. These are arbitrary, but globally unique Strings
 * from the Affordances collection representing an API.
 * Example: 'entry', or 'get-users'
 * @param response should be a String representative of a response code from a client-server protocol capable of
 * facilitating REST.
 * Example: '200', or '400' given HTTP as the transfer protocol.
 * @param message should be an Array of String identifiers representing the Affordances allowed within the message of
 * the request-response transaction.
 * Example: ['entry'], or ['entry', 'get-users']
 * @return {Message}
 */
function message(request, response, message) {
    return new Message(request, response, message);
}

/**
 * Convenience method to allow for type checking outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to test the prototypal inheritance chain on.
 * @return {Boolean}
 */
message.isPrototypeOf = function (object) {
    return object instanceof Message;
};

/**
 * Convenience method to allow for duck-type checking of a generic Object outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to duck-type check as a Message.
 * @return {Boolean}
 */
message.canRevive = function (object) {
    /**
     * Is the argument an Object, and does it have the minimum properties necessary to be duck-typed a Message?
     */
    return !!object &&
        typeof object === 'object' &&
        typeof object._request === 'string' &&
        typeof object._response === 'string' &&
        Array.isArray(object._message);
};

/**
 * Convenience method to allow for reviving a JSON encoded Message outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to revive to a Message instance.
 * @return {Message} if revivable; null, otherwise.
 */
message.revive = function (object) {
    if (!!object &&
        typeof object === 'object' &&
        typeof object._request === 'string' &&
        typeof object._response === 'string' &&
        Array.isArray(object._message)) {
        var instance =
                new Message()
                    .setRequest(object._request)
                    .setResponse(object._response),
            message = object._message;

        for (var id in message) {
            id = message[id];
            instance.addAffordance(id);
        }
        return instance;
    }
    return null;
};

module.exports = exports = message;
