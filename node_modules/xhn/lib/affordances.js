/**
 * Falsy Values: false, 0, "", null, undefined, NaN
 */

/**
 * Augments the Function type object's prototype with a method called "method."
 * This method allows any Constructor Function, that prototypally inherits from
 * Function.prototype (so all Constructor Functions), to easily add methods to
 * their own prototype objects.
 *
 * @param name is the name of the method passed as a String object argument.
 * @param func is the first-class function object passed in as an argument.
 * @return {*} a reference to your respective Constructor Function.
 */
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};

/**
 * Module Dependencies.
 */
var affordance = require('./affordance.js');

/**
 * Represents a collection of Affordance instances.
 *
 * @param id should be a string representative of a globally-unique identifier for the respective Affordances instance
 * when serialized to a document using an encoder. This argument is optional.
 * @return {*}
 * @constructor
 */
function Affordances(id) {
    if (typeof id === 'string') {
        this._id = id;
    }
    this._affordances = [];
    return this;
}

/**
 * Accessor method to allow the setting of the id field.
 *
 * @param id should be a string representative of a globally-unique identifier for the respective Affordances instance
 * when serialized to a document using an encoder.  This field is optional.
 * @return {*} for chaining.
 */
Affordances.method('setId', function (id) {
    this._id = (typeof id === 'string') ? id : this._id;
    return this;
});

/**
 * Accessor method to allow the setting of the metadata field.
 *
 * @param metadata should be an object representative of protocol headers.
 * Example: {'Content_Type':'application/json'}
 * @return {*} for chaining.
 */
Affordances.method('setMetadata', function (metadata) {
    this._metadata = (!!metadata && (typeof metadata === 'object')) ? metadata : this._metadata;
    return this;
});

/**
 * Allows for the addition of an Affordance or Affordances instance to the Affordances collection.
 *
 * @param action should be an instance of Affordance or Affordances.
 * @return {*} for chaining.
 */
Affordances.method('addAffordance', function (action) {
    if ((affordance.isPrototypeOf(action) || action instanceof Affordances) &&
        (this._affordances.lastIndexOf(action) === -1)) {
        this._affordances.push(action);
    }
    return this;
});

/**
 * Retrieve an instance of Affordance or Affordances from the collection of Affordances by its identifier.
 *
 * @param id is a String identifier for the Affordance or Affordances being retrieved.
 * @return {Affordance} or {Affordances} if found; null, otherwise.
 */
Affordances.method('getAffordanceById', function (id) {
    if (typeof id === 'string') {
        /**
         * Get a stack frame reference to the Array of affordances contained within this instance.
         * The reference will always be an Array. The reference to the field is never modified directly.
         *
         * If a match is found, then return the reference to the Affordance.
         * Else, return null.
         */
        var affordances = this._affordances;
        /**
         * Iterate through the Array, and attempt to introspect each Object contained for their respective identifier.
         * If the Array is empty, the fast enumeration does not take place.
         */
        for (var affordance in affordances) {
            /**
             * Dereference each index in the Array. Each returned Object is guaranteed to be an instance of Affordance
             * or Affordances.
             */
            affordance = affordances[affordance];
            /**
             * The _id property may yield undefined on an instance of Affordances. If defined, it is a String.
             * The _id property is guaranteed to yield a String on an instance of Affordance. The String may be empty.
             * This checks if undefined or the String is equivalent to the String passed in the id argument.
             * This is not a reference check.
             */
            if (affordance._id === id) {
                return affordance;
            }
            /**
             * If the dereferenced index yielded an Affordances instance, and the _id being searched for was not the
             * identifier of the collection itself, then iterate through the nested Affordance or Affordances instances.
             */
            if (affordance instanceof Affordances) {
                affordance = affordance.getAffordanceById(id);
                /**
                 * Only return if an instance of Affordance or Affordances was found by the identifier.
                 * Else, keep searching the Array on the current level of recursion.
                 */
                if (!!affordance) {
                    return affordance;
                }
            }
        }
    }
    return null;
});

/**
 * Convenience method to enforce safe method invocations without the use of the new operator.
 *
 * @return {Affordances}
 */
function affordances(id) {
    return new Affordances(id);
}

/**
 * Convenience method to allow for type checking outside of the scope of this module.
 * @param object is a reference to an object you would like to test the prototypal inheritance chain on.
 * @return {Boolean}
 */
affordances.isPrototypeOf = function (object) {
    return object instanceof Affordances;
};

/**
 * Convenience method to allow for duck-type checking of a generic Object outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to duck-type check as an Affordances.
 * @return {Boolean}
 */
affordances.canRevive = function (object) {
    /**
     * Is the argument an Object, and does it have the minimum properties necessary to be duck-typed an Affordances?
     */
    return !!object &&
        typeof object === 'object' &&
        Array.isArray(object._affordances);
};

/**
 * Convenience method to allow for reviving a JSON encoded Affordances outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to revive to an Affordances instance.
 * @return {Affordances}
 */
affordances.revive = function (object) {
    /**
     * If the argument is an Object, then create an instance of Affordances and attempt to copy the arguments fields to
     * the instance.
     */
    if (!!object && typeof object === 'object') {
        var instance =
                new Affordances()
                    .setId(object._id)
                    .setMetadata(object._metadata),
            affordances = object._affordances;

        if (Array.isArray(affordances)) {
            for (var affordance in affordances) {
                affordance = affordances[affordance];
                instance.addAffordance(affordance);
            }
        }
        return instance;
    }
    /**
     * If the argument is not an Object, then return null as it cannot be revived.
     */
    return null;
};

module.exports = exports = affordances;
