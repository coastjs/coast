/**
 * Falsy Values: false, 0, "", null, undefined, NaN
 */

/**
 * Augments the Function type object's prototype with a method called "method."
 * This method allows any Constructor Function, that prototypally inherits from
 * Function.prototype (so all Constructor Functions), to easily add methods to
 * their own prototype objects.
 *
 * @param name is the name of the method passed as a String object argument.
 * @param func is the first-class function object passed in as an argument.
 * @return {*} a reference to your respective Constructor Function.
 */
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};

/**
 * Simple, command line options parser that expects the Node.JS arguments vector.
 *
 * @param options should be an [{string}]. Each string should be an expected option that does NOT contain a '-' or '='
 * character (defined by the default style Regular Expression). However, no input validation is conducted because the
 * user of this module may choose to change the default option style later.
 *
 * Default styles are:
 *  --[option]=[value]
 *  -[option]=[value]
 *  --[option]
 *  -[option]
 *
 * Example: ['port', 'host'] means you expect options to look like:
 * --port=80
 * --host=127.0.0.1
 * -port=80
 * -host=127.0.0.1
 * --port
 * --host
 * -port
 * -host
 *
 * They are NOT required to have an accompanying value, but if they do, the value will be parsed with the default style.
 *
 * @return {*}
 * @constructor
 */
function Options(options) {
    this._options = Array.isArray(options) ? options : [];
    this._style = /^--?([^-=]+)(?:=(.+))?$/;
    this._values = {};
    return this;
}

/**
 * Accessor method that allows for setting a style of options to look for in the arguments vector.
 * The style should be represented by a Regular Expression.
 *
 * @param style should be an instance of {RegExp}.
 * @return {*} for chaining.
 */
Options.method('setStyle', function (style) {
    this._style = style instanceof RegExp ? style : this._style;
    return this;
});

/**
 * Parse expects the Node.JS arguments vector (process.argv) as an argument.
 *
 * It will enumerate the arguments vector, and check if each argument in the vector conforms the options style
 * specified by a Regular Expression. If an argument does conform, by default, the option and its accompanying value
 * will be set as a key/value pair on an internal Object. This Object may be introspected with Options.get or
 * Options.has.
 *
 * @param argv should be the Node.JS arguments vector [{string}]. It can effectively be any [{string}], but seems rather
 * pointless to not just directly pass in the default arguments vector.
 * @return {*} for chaining.
 */
Options.method('parse', function (argv) {
    var options = this._options,
        style = this._style,
        values = this._values;

    /**
     * If the argument is an Array, then enumerate it.
     */
    if (Array.isArray(argv)) {
        for (var arg in argv) {
            /**
             * Check each argument in the Array against the specified options style.
             *
             * If the match succeeds, the exec method returns an array and updates properties of the regular expression
             * object. The returned array has the matched text as the first item, and then one item for each capturing
             * parenthesis that matched containing the text that was captured.
             *
             * If the match fails, the exec method returns null.
             */
            var pair = style.exec(argv[arg]);
            /**
             * If the argument passed the conformance check, then it is at the very least an option, and at the very
             * most an option with accompanying value (according to the default style). This may change if the user
             * of this module changes the default style.
             */
            if (!!pair) {
                pair = pair.slice(1);
                /**
                 * For the sake of simplicity,
                 * If an argument passes the conformance check of a style,
                 * Then the argument must, at least, have one capturing group representing an option,
                 * And, at most, have two capturing groups representing an option and value.
                 *
                 * The default option style captures options and values delimited by an '=' character.
                 * The option should be index 0 in the sliced Array, and the value should be index 1.
                 */
                var option = pair[0],
                    value = pair[1];

                /**
                 * If the option is acknowledged by the user in the options Array,
                 * Then keep track of its value in the values Object.
                 *
                 * Value may be a captured, non-empty {string} or undefined if nothing was captured.
                 */
                if (options.lastIndexOf(option) !== -1) {
                    /**
                     * If a value was captured,
                     * Then retain it.
                     * Else, set the value to true explicitly to acknowledge that the option was set. This is necessary
                     * for property introspection of the values Object.
                     */
                    values[option] = !!value ? value : true;
                }
            }
        }
    }
    return this;
});

/**
 * Has is an introspective method that allows for checking if an option exists after parsing the arguments vector.
 *
 * @param option should be a {string} indicative of the name of the option.
 * @return {boolean} true if the option exists; {boolean} false, otherwise.
 */
Options.method('has', function (option) {
    /**
     * If the option exists as a property of the values Object, then the returned value must be a truthy, non-empty
     * {string}, or true. Else, the property does not exist, and dereferencing it yields undefined.
     *
     * In the case that it yields undefined, false it returned. Else, true is returned.
     */
    return !!this._values[option];
});

/**
 * Get is an introspective method that allows for retrieving the value of an option after parsing the arguments vector.
 *
 * @param option should be a {string} indicative of the name of the option.
 * @return a non-empty {string} if the value exists; undefined, otherwise.
 */
Options.method('get', function (option) {
    /**
     * If the option exists as a property of the values Object, then the returned value must be a truthy, non-empty
     * {string}, or true. Else, the property does not exist, and dereferencing it yields undefined.
     */
    return this._values[option];
});

/**
 * Convenience method to enforce safe method invocations without the use of the new operator.
 *
 * @return {Options}
 */
function options(options) {
    return new Options(options);
}

/**
 * Convenience method to allow for type checking outside of the scope of this module.
 *
 * @param object is a reference to an object you would like to test the prototypal inheritance chain on.
 * @return {Boolean}
 */
options.isPrototypeOf = function (object) {
    return object instanceof Options;
};

module.exports = exports = options;
